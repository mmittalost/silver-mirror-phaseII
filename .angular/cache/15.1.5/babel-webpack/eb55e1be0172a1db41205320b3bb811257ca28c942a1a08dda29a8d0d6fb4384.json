{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport class LocationGroupPipe {\n  transform(collection, property) {\n    // prevents the application from breaking if the array of objects doesn't exist yet\n    console.log(\"groupedCollection\", collection);\n    const groupedCollection = collection.reduce((previous, current) => {\n      if (!previous[current[property]]) {\n        previous[current[property.node.address.city]] = [current.node.address.city];\n      } else {\n        previous[current[property.node.address.city]].push(current.node.address.city);\n      }\n      return previous;\n    }, {});\n    console.log(\"groupedCollection\", groupedCollection);\n    // this will return an array of objects, each object containing a group of objects\n    console.log(\"==>\", Object.keys(groupedCollection).map(key => ({\n      key,\n      value: groupedCollection[key]\n    })));\n    return Object.keys(groupedCollection).map(key => ({\n      key,\n      value: groupedCollection[key]\n    }));\n  }\n}\nLocationGroupPipe.ɵfac = function LocationGroupPipe_Factory(t) {\n  return new (t || LocationGroupPipe)();\n};\nLocationGroupPipe.ɵpipe = /*@__PURE__*/i0.ɵɵdefinePipe({\n  name: \"locationGroup\",\n  type: LocationGroupPipe,\n  pure: true\n});","map":{"version":3,"mappings":";AAKA,OAAM,MAAOA,iBAAiB;EAE5BC,SAAS,CAACC,UAAiB,EAAEC,QAAa;IACxC;IACAC,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAACH,UAAU,CAAC;IAC3C,MAAMI,iBAAiB,GAAGJ,UAAU,CAACK,MAAM,CAAC,CAACC,QAAQ,EAAEC,OAAO,KAAG;MAC7D,IAAG,CAACD,QAAQ,CAACC,OAAO,CAACN,QAAQ,CAAC,CAAC,EAAE;QAC7BK,QAAQ,CAACC,OAAO,CAACN,QAAQ,CAACO,IAAI,CAACC,OAAO,CAACC,IAAI,CAAC,CAAC,GAAG,CAACH,OAAO,CAACC,IAAI,CAACC,OAAO,CAACC,IAAI,CAAC;OAC9E,MAAM;QACHJ,QAAQ,CAACC,OAAO,CAACN,QAAQ,CAACO,IAAI,CAACC,OAAO,CAACC,IAAI,CAAC,CAAC,CAACC,IAAI,CAACJ,OAAO,CAACC,IAAI,CAACC,OAAO,CAACC,IAAI,CAAC;;MAGjF,OAAOJ,QAAQ;IACnB,CAAC,EAAE,EAAE,CAAC;IACVJ,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAACC,iBAAiB,CAAC;IAC9C;IACAF,OAAO,CAACC,GAAG,CAAC,KAAK,EAACS,MAAM,CAACC,IAAI,CAACT,iBAAiB,CAAC,CAACU,GAAG,CAACC,GAAG,KAAK;MAAEA,GAAG;MAAEC,KAAK,EAAEZ,iBAAiB,CAACW,GAAG;IAAC,CAAE,CAAC,CAAC,CAAC;IACtG,OAAOH,MAAM,CAACC,IAAI,CAACT,iBAAiB,CAAC,CAACU,GAAG,CAACC,GAAG,KAAK;MAAEA,GAAG;MAAEC,KAAK,EAAEZ,iBAAiB,CAACW,GAAG;IAAC,CAAE,CAAC,CAAC;EAC5F;;AAlBWjB,iBAAiB;mBAAjBA,iBAAiB;AAAA;AAAjBA,iBAAiB;;QAAjBA,iBAAiB;EAAAmB;AAAA","names":["LocationGroupPipe","transform","collection","property","console","log","groupedCollection","reduce","previous","current","node","address","city","push","Object","keys","map","key","value","pure"],"sourceRoot":"","sources":["C:\\wamp64\\www\\SMP2\\silver-mirror-phaseII\\silver-mirror-phaseII\\src\\app\\location-group.pipe.ts"],"sourcesContent":["import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'locationGroup'\n})\nexport class LocationGroupPipe implements PipeTransform {\n\n  transform(collection: any[], property: any): any[] {\n    // prevents the application from breaking if the array of objects doesn't exist yet\n    console.log(\"groupedCollection\",collection);\n    const groupedCollection = collection.reduce((previous, current)=> {\n        if(!previous[current[property]]) {\n            previous[current[property.node.address.city]] = [current.node.address.city];\n        } else {\n            previous[current[property.node.address.city]].push(current.node.address.city);\n        }\n\n        return previous;\n    }, {});\nconsole.log(\"groupedCollection\",groupedCollection);\n    // this will return an array of objects, each object containing a group of objects\n    console.log(\"==>\",Object.keys(groupedCollection).map(key => ({ key, value: groupedCollection[key] })));\n    return Object.keys(groupedCollection).map(key => ({ key, value: groupedCollection[key] }));\n  }\n\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}