{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport class LocationGroupPipe {\n  transform(value, filter) {\n    const groupDataByCity = data => {\n      const locations = data.locations.edges.map(edge => edge.node);\n      const groupedLocations = locations.reduce((acc, location) => {\n        const city = location.address.city;\n        if (acc[city]) {\n          acc[city].push(location);\n        } else {\n          acc[city] = [location];\n        }\n        return acc;\n      }, {});\n      return groupedLocations;\n    };\n  }\n}\nLocationGroupPipe.ɵfac = function LocationGroupPipe_Factory(t) {\n  return new (t || LocationGroupPipe)();\n};\nLocationGroupPipe.ɵpipe = /*@__PURE__*/i0.ɵɵdefinePipe({\n  name: \"locationGroup\",\n  type: LocationGroupPipe,\n  pure: true\n});","map":{"version":3,"mappings":";AAKA,OAAM,MAAOA,iBAAiB;EAE1BC,SAAS,CAACC,KAAY,EAAEC,MAAc;IAEpC,MAAMC,eAAe,GAAIC,IAAuC,IAAI;MACpE,MAAMC,SAAS,GAAGD,IAAI,CAACC,SAAS,CAACC,KAAK,CAACC,GAAG,CAACC,IAAI,IAAIA,IAAI,CAACC,IAAI,CAAC;MAC7D,MAAMC,gBAAgB,GAAGL,SAAS,CAACM,MAAM,CAAC,CAACC,GAAG,EAAEC,QAAQ,KAAI;QAC1D,MAAMC,IAAI,GAAGD,QAAQ,CAACE,OAAO,CAACD,IAAI;QAClC,IAAIF,GAAG,CAACE,IAAI,CAAC,EAAE;UACbF,GAAG,CAACE,IAAI,CAAC,CAACE,IAAI,CAACH,QAAQ,CAAC;SACzB,MAAM;UACLD,GAAG,CAACE,IAAI,CAAC,GAAG,CAACD,QAAQ,CAAC;;QAExB,OAAOD,GAAG;MACZ,CAAC,EAAE,EAAE,CAAC;MACN,OAAOF,gBAAgB;IAE7B,CAAC;EACG;;AAlBSX,iBAAiB;mBAAjBA,iBAAiB;AAAA;AAAjBA,iBAAiB;;QAAjBA,iBAAiB;EAAAkB;AAAA","names":["LocationGroupPipe","transform","value","filter","groupDataByCity","data","locations","edges","map","edge","node","groupedLocations","reduce","acc","location","city","address","push","pure"],"sourceRoot":"","sources":["C:\\wamp64\\www\\SMP2\\silver-mirror-phaseII\\silver-mirror-phaseII\\src\\app\\location-group.pipe.ts"],"sourcesContent":["import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'locationGroup'\n})\nexport class LocationGroupPipe implements PipeTransform {\n\n    transform(value: any[], filter: string)\n    {\n      const groupDataByCity = (data: { locations: { edges: any[]; }; }) => {\n      const locations = data.locations.edges.map(edge => edge.node);\n      const groupedLocations = locations.reduce((acc, location) => {\n        const city = location.address.city;\n        if (acc[city]) {\n          acc[city].push(location);\n        } else {\n          acc[city] = [location];\n        }\n        return acc;\n      }, {});\n      return groupedLocations;\n\n}\n    }\n  }\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}